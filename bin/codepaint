#!/usr/bin/env node

var clc = require('cli-color');
var crypto = require('crypto');
var editorconfig = require('editorconfig');
var extend = require('node.extend');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var program = require('commander');

var package = require("../package.json");
var Transformer = require('../lib/Transformer');


var style = {};

function setting(val) {
	return keyValue(val, style);
}

function keyValue(val, store) {
	val = val.split('=');
	store[val[0]] = parseValue(val[1]);
	return val;
}

function parseValue(value){
	try {
		return JSON.parse(value);
	} catch(e){
		return value;
	}
}

program.version('Code Painter ' + package.version + ' beautifies JavaScript.');

program
.usage(['[options] "glob" ["glob" ...]', program._version].join("\n\n  "))
.option('-i, --infer <path>',			'code sample to infer')
.option('-p, --predef <name>',			'specify predefined style (idiomatic|...)')
.option('-j, --json <path>',			'JSON file with style settings')
.option('-s, --style <key>=<value>',	'an individual style setting', setting)
.option('-e, --editor-config',			'enable rules via EditorConfig')
.option('-C, --no-color',				'disable color escape codes')
.parse(process.argv);

program.on('--help', function(){
	console.log('  Examples:');
	console.log('');
	console.log('    $', clc.cyan('codepaint "**/*.js"'));
	console.log('    $ codepaint', clc.cyan('"**/*view.js" "**/*model.js"'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-i sample.js'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-p idiomatic'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-j custom.json'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s quote_type=null'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-s indent_style=space -s indent_size=4'));
	console.log('    $ codepaint %s "**/*.js"', clc.cyan('-e'));
	console.log('');
});

if(program.rawArgs.length === 2 && process.stdin.isTTY) {
	program.help();
}

program.style = style;
program.globs = program.args;

function cascade(styleBefore, styleToMerge, styleType){
	if (Object.keys(styleToMerge).length === 0){
		return;
	}
	console.log('');
	console.log('  ' + styleType + ':');
	var color;
	Object.keys(styleToMerge).forEach(function(key){
		var msg = key + ' = ' + styleToMerge[key];
		if (key in style) {
			if (style[key] === styleToMerge[key]){
				msg = '= ' + msg;
				color = clc.blackBright;
			} else if (styleToMerge[key] === null){
				msg = '   x ' + msg;
				delete style[key];
				console.log(program.color ? clc.red(msg) : msg);
				return;
			} else {
				msg = '* ' + msg;
				color = clc.cyan;
			}
		} else {
			msg = '+ ' + msg;
			color = clc.green;
		}
		console.log('   ' + (program.color ? color(msg) : msg));
	});
}

var transformer = new Transformer(program);

if (program.globs.length || process.stdin.isTTY) {
	transformer.on('cascade', cascade);

	transformer.once('transform', function(){
		process.stdout.write('\n  ');
	});

	transformer.on('transform', function(transformed, path){
		if (transformed % 70 === 0) {
			process.stdout.write('\n  ');
		}
		process.stdout.write('.');
	});

	transformer.on('error', function(err, inputPath){
		error(err.message + ' ' + inputPath);
	});

	transformer.on('end', function(err, transformed, skipped, errored){
		displayFinalMessage(transformed, skipped, errored);
		if (err) process.exit(1);
	});
}

transformer.transform();

function error(msg){
	msg = 'Error: ' + msg;
	if (program.color) {
		msg = clc.red(msg);
	}
	msg = '\n  ' + msg;
	if (typeof arguments[1] !== 'undefined') {
		console.log(msg, arguments[1]);
	} else {
		console.log(msg);
	}
}

function displayFinalMessage(transformed, skipped, errored) {
	console.log('\n');
	var msg = '  REPORT: %s transformed. %s errored. %s skipped (no rules).';
	if (program.color) {
		msg = clc.magenta(msg);
	}
	console.log(msg, transformed, errored, skipped);
	console.log('');
}
