#!/usr/bin/env node

var fs = require('fs'),
    path = require('path'),
    spawn = require('child_process').spawn,
    optimist = require('optimist'),
    codepainter = require('../codepainter');

var argv = optimist.options({
    'input': {
        alias: 'i',
        'default': 'stdin',
        describe: 'File path to read from',
        type: 'string'
    },
    'output': {
        alias: 'o',
        'default': 'stdout',
        describe: 'File path to write to',
        type: 'string'
    },
    'sample': {
        alias: 's',
        describe: 'Code sample path from which to infer the style',
        type: 'string'
    },
    'style': {
        describe: 'A predefined style or a JSON string describing the coding style',
        type: 'string'
    },
    'stylefile': {
        describe: 'File containing a JSON string describing the coding style',
        type: 'string'
    }
})
.usage('CodePainter beautifies JavaScript.\nUsage: $0 [options]')
.argv;

var input;
if (argv.input === 'stdin') {
    input = process.stdin;
} else {
    input = fs.createReadStream(argv.input);
    input.pause();
}
input.setEncoding('utf-8');

var output;
if (argv.output === 'stdout') {
    output = process.stdout;
} else {
    output = fs.createWriteStream(argv.output);
}

function transform(style) {
    codepainter.transform(input, style, output);
}

function parseValue( value ) {
    value = value.toLowerCase();
    if( value === 'true' ) {
        return true;
    }
    if( value === 'false' ) {
        return false;
    }
    var iValue = parseInt( value, 10 );
    if( iValue == value ) {
        return iValue;
    }
    return value;
}

function convertEditorConfigPropsToObject( props ) {
    var result = {};
    props = props.match( /[^\s=]+\s*=\s*[^\s=]+/g );
    for( var i = 0; i < props.length; i++ ) {
        var pair = props[i].split('=');
        result[ pair[0] ] = parseValue( pair[1] );
    }
    return result;
}

try {
    if (typeof argv.style !== 'undefined') {

        transform(argv.style);

    } else if (typeof argv.stylefile !== 'undefined') {

        transform(fs.readFileSync(argv.stylefile));

    } else {

        var style = {},
            ec = spawn('../editorconfig-core/bin/release/editorconfig', [ path.resolve( argv.input )]);

        ec.stdout.setEncoding('utf8');
        ec.stdout.on('data', function( data ) {
            style = convertEditorConfigPropsToObject( data );
        });

        ec.on('close', function(code) {
            var keys = Object.keys( style );
            if( keys.length ) {

                transform( style );

            } else if( typeof argv.sample !== 'undefined' ) {

                var sample = fs.createReadStream(argv.sample);
                sample.pause();
                sample.setEncoding('utf-8');

                codepainter.infer(sample, transform);

            } else {

                throw new Error( 'You must specify one of the following: ' +
                    '.editorconfig file, sample file, style string or style file.' );

            }
        });

    }
} catch (e) {
    console.error( 'Error: ' + e.message );
    optimist.showHelp( console.error );
}
